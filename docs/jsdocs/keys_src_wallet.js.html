

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      keys/src/wallet.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Democracy
    </h3>

    

    <h3>Classes</h3><ul><li id="BuildsManager-nav"><a href="bm.BuildsManager.html">BuildsManager</a></li><li id="ContractsManager-nav"><a href="cm.ContractsManager.html">ContractsManager</a><ul class='methods'><li data-type="method" id="ContractsManager-getContract-nav"><a href="cm.ContractsManager.html#getContract">getContract</a></li></ul></li><li id="Contract-nav"><a href="contract.Contract.html">Contract</a></li><li id="Compiler-nav"><a href="module-compile.Compiler.html">Compiler</a></li></ul><h3>Modules</h3><ul><li id="api-nav"><a href="module-api.html">api</a><ul class='methods'><li data-type="method" id="api-init-nav"><a href="module-api.html#.init">init</a></li><li data-type="method" id="api-initFS-nav"><a href="module-api.html#.initFS">initFS</a></li><li data-type="method" id="api-prepareCachedWallet-nav"><a href="module-api.html#.prepareCachedWallet">prepareCachedWallet</a></li><li data-type="method" id="api-prepareErasePassword-nav"><a href="module-api.html#.prepareErasePassword">prepareErasePassword</a></li><li data-type="method" id="api-prepareUpdateWhileCached-nav"><a href="module-api.html#.prepareUpdateWhileCached">prepareUpdateWhileCached</a></li><li data-type="method" id="api-relockErasePassword-nav"><a href="module-api.html#.relockErasePassword">relockErasePassword</a></li></ul></li><li id="compile-nav"><a href="module-compile.html">compile</a><ul class='methods'><li data-type="method" id="compile-compile-nav"><a href="module-compile.html#.compile">compile</a></li><li data-type="method" id="compile-updateFlatten-nav"><a href="module-compile.html#.updateFlatten">updateFlatten</a></li></ul></li><li id="contract-nav"><a href="module-contract.html">contract</a><ul class='methods'><li data-type="method" id="contract-createContract-nav"><a href="module-contract.html#.createContract">createContract</a></li><li data-type="method" id="contract-getInstance-nav"><a href="module-contract.html#.getInstance">getInstance</a></li><li data-type="method" id="contract-init-nav"><a href="module-contract.html#.init">init</a></li></ul></li><li id="utils-nav"><a href="module-utils.html">utils</a><ul class='methods'><li data-type="method" id="utils-getConfig-nav"><a href="module-utils.html#.getConfig">getConfig</a></li><li data-type="method" id="utils-parseLogLevels-nav"><a href="module-utils.html#.parseLogLevels">parseLogLevels</a></li><li data-type="method" id="utils-textsEqual-nav"><a href="module-utils.html#.textsEqual">textsEqual</a></li></ul></li><li id="wallet-nav"><a href="module-wallet.html">wallet</a><ul class='methods'><li data-type="method" id="wallet-createEncryptedAccount-nav"><a href="module-wallet.html#.createEncryptedAccount">createEncryptedAccount</a></li><li data-type="method" id="wallet-createSignerEth-nav"><a href="module-wallet.html#.createSignerEth">createSignerEth</a></li><li data-type="method" id="wallet-init-nav"><a href="module-wallet.html#.init">init</a></li><li data-type="method" id="wallet-loadEncryptedAccount-nav"><a href="module-wallet.html#.loadEncryptedAccount">loadEncryptedAccount</a></li><li data-type="method" id="wallet-pay-nav"><a href="module-wallet.html#.pay">pay</a></li><li data-type="method" id="wallet-payTest-nav"><a href="module-wallet.html#.payTest">payTest</a></li><li data-type="method" id="wallet-prepareSignerEth-nav"><a href="module-wallet.html#.prepareSignerEth">prepareSignerEth</a></li><li data-type="method" id="wallet-saveEncryptedAccount-nav"><a href="module-wallet.html#.saveEncryptedAccount">saveEncryptedAccount</a></li><li data-type="method" id="wallet-unlockEncryptedAccount-nav"><a href="module-wallet.html#.unlockEncryptedAccount">unlockEncryptedAccount</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#getFileKeySpace">getFileKeySpace</a></li><li><a href="global.html#path">path</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        keys/src/wallet.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>/**
 * Wallet functions and state
 *
 * @memberof module:wallet
 */
const assert = require('chai').assert

const {
  getNetwork, getConfig, getEndpointURL, Logger, toJS, fromJS, 
  awaitInputter, awaitOutputter } = require('demo-utils')
const LOGGER = new Logger('wallet')

const BN = require('bn.js')
const randombytes = require('randombytes')
const SignerProvider = require('ethjs-provider-signer')
const ethsign = require('ethjs-signer').sign
const Eth     = require('ethjs')
const keys = require('./keys')
const { toWei, fromWei } = require('web3-utils')
const { isValidAddress, toChecksumAddress } = require('ethereumjs-util')
const { createInOut } = require('demo-client')

const wallet = {}

/**
 * Convenience method to create a new account if no address/password is given,
 * otherwise load and unlock the given address
 * from the (remote) store. Finally create a signerEth with it.
 * Equivalent to calling
 * `wallet.loadEncryptedAccount`, `wallet.unlockEncryptedAccount`, `wallet.createSignerEth`
 *
 * @method prepareSignerEth
 * @memberof module:wallet
 * @param address {String} `0x`-prefixed Ethereum address to create a signer around
 * @param password {String} password to unlock the given Ethereum account
 * @return address {String} a `0x`-prefixed Ethereum address, auto-created if missing `address` param
 * @return password {String} a hex password string, auto-created if missing `password` param
 * @return signerEth {Eth} an Ethereum network object, tied to above address, signing transactions and spending funds from it
 */
wallet.prepareSignerEth = async ({ address, password }) => {
  const autoCreate = !address &amp;&amp; !password
  const pair  = (autoCreate) ? (await wallet.createEncryptedAccount()) :
    { address: address, password: password }
  const _address  = toChecksumAddress(pair.address)
  const _password = pair.password
  LOGGER.debug('AUTO', _address, _password)

  await wallet.loadEncryptedAccount({ address: _address })
  await wallet.unlockEncryptedAccount({ address: _address, password: _password })
  wallet.lastSignerEth = wallet.createSignerEth({ url: getEndpointURL(), address: _address }) 
  return {
    address   : _address,
    password  : _password,
    signerEth : wallet.lastSignerEth,
  }
}

wallet.validatePassword = async ({ address, password }) => {
  try {
    await wallet.loadEncryptedAccount({ address })
    await wallet.unlockEncryptedAccount({ address, password })
    return true
  } catch(e) {
    return false
  }
}

wallet.createFromPrivateString = async ({ privateString }) => {
  const account = keys.createFromPrivateString(privateString)
  const address = account.get('addressPrefixed')
  const password = randombytes(32).toString('hex')
  const encryptedJSON = keys.accountToEncryptedJSON({ account: account, password: password })
  const result = await wallet.saveEncryptedAccount({
    address: address, encryptedAccount: encryptedJSON })
  return {
    password : password,
    address  : address,
    result   : result,
    account  : account
  }
}

/**
 * Create a signer provider given the current URL and account.
 * TODO: change democracy API to return the endpoint url from a config name
 *
 * @method createSignerEth
 * @memberof module:wallet
 * @param url {String} the URL of an endpoint
 * @param address {String} `0x`-prefixed Ethereum address of sender
 */
wallet.createSignerEth = ({url, address}) => {
  assert( isValidAddress(address), `Invalid Ethereum address ${address}` )
  const checksumAddress = toChecksumAddress(address)
  const provider = new SignerProvider(url, {
    signTransaction: async (rawTx, cb) => {
      let account = wallet.accountsMap[checksumAddress]
      if ( keys.isAccount(account) ) {
        cb(null, ethsign(rawTx, account.get('privatePrefixed') ) )
      } else {
        throw new Error(`Account ${address} is locked. Call wallet.unlockEncryptedAccount`)
      }
    },
    accounts: (cb) => cb(null, [checksumAddress]),
  })
  const newEth = new Eth(provider)
  newEth.address = checksumAddress
  wallet.signersMap[checksumAddress] = newEth
  LOGGER.debug(`Added a signer for ${address}`)
  return newEth
}

wallet.initialized = false
wallet.inputter = null
wallet.outputter = null
wallet.accountsMap = {}
wallet.signersMap = {}
wallet.relockMap = {}
wallet.eth = getNetwork()

wallet.UNLOCK_TIMEOUT_SECONDS = 600
// The measured gas costs of transferring 100 ETH
wallet.OVERAGE_100_ETH = toWei('0.0134', 'ether')
wallet.unlock_seconds

/**
 * Initialize the wallet.
 *
 * @method init
 * @memberof module:wallet
 * @param autoConfig {boolean}
 * @param unlockSeconds {Number}
 */
wallet.init = async ({ autoConfig, unlockSeconds }) => {
  if (wallet.initialized) { LOGGER.debug('Wallet already initialized.'); return }
  const _autoConfig = autoConfig || true // save it remotely by default
  if (!require('keythereum')) {
    LOGGER.error('Missing keythereum, did you add a script tag?')
  }
  const inout = await createInOut({autoConfig: _autoConfig})
  wallet.inputter = inout.inputter
  wallet.outputter = inout.outputter
  wallet.unlockSeconds = (unlockSeconds) ? unlockSeconds : wallet.UNLOCK_TIMEOUT_SECONDS
  wallet.chainId = await wallet.eth.net_version()
  wallet.initialized = true
}

/**
 * Create an encrypted account.
 *
 * @method createEncryptedAccount
 * @memberof module:wallet
 * @param creatorFunc {Function} a factory function with no parameters that
 *   returns an account as an Immutable Map, with possible extra leading
 *   bytes in the public key that can be safely ignored / sliced.
 * @return address {String} a `0x`-prefixed Ethereum address
 * @return password {String} a random password string
 * @return encryptedAccount {JSON} the geth-format enciphered Ethereum private key
 * @return result {JSON} the result of saving the encryptedAccount to a (remote) store
 */
wallet.createEncryptedAccount = async () => {
  if (!wallet.initialized) { LOGGER.error('Call wallet.init() first.') }
  const account = keys.create()
  const address = account.get('addressPrefixed')
  const password = randombytes(32).toString('hex')
  const encryptedAccount = keys.accountToEncryptedJSON({
    account: account, password: password })
  const result = await wallet.saveEncryptedAccount({
    address: address, encryptedAccount: encryptedAccount })
  assert( result, `Saving encrypted account for ${address} ${encryptedAccount} failed` )
  return {
    address          : address,
    password         : password,
    result           : result,
    encryptedAccount : encryptedAccount,
  }
} 

/**
 * Retrieves encrypted account for this address from a (possibly remote) persistent store.
 *
 * @method loadEncryptedAccount
 * @memberof module:wallet
 * @param address {String} `0x`-prefixed Ethereum address associated with desired account.
 * @return encrypted JSON account for the given address.
 */
wallet.loadEncryptedAccount = async ({ address }) => {
  if (!wallet.initialized) { LOGGER.error('Call wallet.init() first.') }
  const checksumAddress = toChecksumAddress(address)
  return awaitInputter(
    wallet.inputter(`keys/${wallet.chainId}/${address}`, null),
    (encryptedAccount) => {
      if (!encryptedAccount) { throw new Error(`Account not found for ${address}`) }
      wallet.accountsMap[checksumAddress] =
        toJS( encryptedAccount )
      LOGGER.debug(`Loaded encrypted account for ${address}`)
      return toJS( encryptedAccount )
    }
  )
}

/**
 * Saves the encrypted account to a (remote) store
 *
 * @method saveEncryptedAccount
 * @memberof module:wallet
 * @param address {String} a `0x`-prefixed Ethereum address associated with this account
 * @param encryptedAccount {JSON} geth-formatted key to save in a (remote) store
 */
wallet.saveEncryptedAccount = async ({ address, encryptedAccount }) => {
  if (!wallet.initialized) { LOGGER.error('Call wallet.init() first.') }
  const checksumAddress = toChecksumAddress(address)
  if (wallet.accountsMap[checksumAddress]) {
    throw new Error(`Attempting to overwrite existing account at ${address}`)
  }
  wallet.accountsMap[checksumAddress] = encryptedAccount
  return awaitOutputter(
    wallet.outputter( `keys/${wallet.chainId}/${address}`, fromJS(encryptedAccount) ),
    // Delay by one second, so that subsequent calls to inputter will return the newly
    // saved key
    (output) => { return new Promise((resolve) => {
      setTimeout(() => { resolve(output) }, 1000)
    }) }
  )
}

/**
 * Unlock an encrypted account.
 *
 * @method unlockEncryptedAccount
 * @memberof module:wallet
 * @param address {String} `0x`-prefixed Ethereum address associated with account to unlock
 * @param password {String} to unlock the given account
 */
wallet.unlockEncryptedAccount = async ({ address, password }) => {
  const checksumAddress = toChecksumAddress(address)
  const encryptedAccount = wallet.accountsMap[checksumAddress]
  if ( keys.isAccount(encryptedAccount) ) {
    throw new Error(`Account ${address} already unlocked`)
  }
  if (!address || !password) {
    throw new Error(`Empty address ${address} or password`)
  }
  wallet.accountsMap[checksumAddress] =
    keys.encryptedJSONToAccount({ encryptedJSON: encryptedAccount,
      password: password })
  const relockFunc = () => {
    wallet.accountsMap[checksumAddress] = encryptedAccount } 
  const id = setTimeout(relockFunc, wallet.unlockSeconds * 1000)
  wallet.relockMap[checksumAddress] = { id: id, relockFunc: relockFunc }
  return relockFunc
}

wallet.lockEncryptedAccountSync = ({ address }) => {
  const checksumAddress = toChecksumAddress(address)
  const { id, relockFunc } = wallet.relockMap[checksumAddress]
  if (id) {
    clearTimeout(id)
    relockFunc()
    delete wallet.relockMap[checksumAddress]
    LOGGER.debug(`Relocked ${address}`)
  }
}

wallet.shutdownSync = () => {
  for (var address in wallet.relockMap) {
    wallet.lockEncryptedAccountSync({ address: address })
  }
}

/**
 * Transfer ETH between the given addresses, whose accounts have already been unlocked.
 *
 * @method pay
 * @memberof module:wallet
 * @param payAll {boolean} whether to transfer all spendable value
 * @param weiValue {String} the amount in wei to transfer (ignored if `payAll` is true)
 * @param fromAddress {String} `0x`-prefixed Ethereum address of sender
 * @param toAddress {String} `0x`-prefixed Ethereum address of receiver
 * @param overage {String} optional, the amount of fees to withhold if `payAll` is true)
 * @param label {String} optional, a debug label to log for this transaction
 */
wallet.pay = async ({payAll, weiValue, fromAddress, toAddress, overage, label}) => {
  const checksumAddress = toChecksumAddress(fromAddress)
  const signer = wallet.signersMap[checksumAddress]
  if (!signer) { throw new Error(`No signer created for address ${fromAddress}`) }
  return wallet.payTest({eth: signer, fromAddress: fromAddress, payAll: payAll, toAddress: toAddress, weiValue: weiValue, overage: overage, label: label}) 
}

/**
 * Pay from a test account (that is already unlocked on the Ethereum node)
 *
 * @method payTest
 * @memberof module:wallet
 * @param weiValue {String} representing the value in wei
 * @param fromAddress {String} Ethereum address of payer/sender
 * @param toAddress {String} Ethereum address of recipient
 */
wallet.payTest = async ({eth, weiValue, fromAddress, toAddress, payAll, overage, label}) => {
  LOGGER.debug('LABEL', label)
  let gasLimit = new BN(getConfig()['GAS_LIMIT'])
  const gasPrice = new BN(getConfig()['GAS_PRICE'])
  const _overage = (overage) ? overage : wallet.OVERAGE_100_ETH
  if (payAll) {
    LOGGER.debug('OVERAGE', fromWei(_overage, 'ether'))
    LOGGER.debug('fromAddress', fromAddress)
    LOGGER.debug('toAddress', toAddress)
    const balance = await wallet.eth.getBalance(fromAddress)
    LOGGER.debug(`payAll for balance of ${fromWei(balance.toString(), 'ether')}`)
    
    const gasEstimate = await wallet.eth.estimateGas({
      from: fromAddress, to: toAddress, value: balance, data: '0x'})
    gasLimit = gasEstimate
    //gasLimit = new BN(gasEstimate).mul(new BN(gasPrice)).mul(new BN(toWei('10', 'gwei')))
    weiValue = new BN(balance).sub(new BN(_overage)).toString(10)
    LOGGER.debug(`Sendable wei value is ${fromWei(weiValue, 'ether')} ETH`)
  }
  const _eth = (eth) ? eth : wallet.eth
  LOGGER.debug(`Sending wei value is ${fromWei(weiValue, 'ether')} ETH`)
  return _eth.sendTransaction({
    value    : weiValue,
    data     : '0x',
    from     : fromAddress,
    to       : toAddress,
    gas      : gasLimit,
    gasPrice : gasPrice,
    nonce    : await wallet.eth.getTransactionCount(fromAddress),
  })
}

wallet.fromWei = fromWei
wallet.toWei   = toWei

module.exports = wallet
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
