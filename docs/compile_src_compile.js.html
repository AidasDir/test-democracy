

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      compile/src/compile.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Democracy
    </h3>

    

    <h3>Classes</h3><ul><li id="BuildsManager-nav"><a href="bm.BuildsManager.html">BuildsManager</a></li><li id="ContractsManager-nav"><a href="cm.ContractsManager.html">ContractsManager</a><ul class='methods'><li data-type="method" id="ContractsManager-getContract-nav"><a href="cm.ContractsManager.html#getContract">getContract</a></li></ul></li><li id="Contract-nav"><a href="contract.Contract.html">Contract</a></li><li id="Compiler-nav"><a href="module-compile.Compiler.html">Compiler</a></li></ul><h3>Modules</h3><ul><li id="compile-nav"><a href="module-compile.html">compile</a><ul class='methods'><li data-type="method" id="compile-compile-nav"><a href="module-compile.html#.compile">compile</a></li><li data-type="method" id="compile-updateFlatten-nav"><a href="module-compile.html#.updateFlatten">updateFlatten</a></li></ul></li><li id="contract-nav"><a href="module-contract.html">contract</a><ul class='methods'><li data-type="method" id="contract-createContract-nav"><a href="module-contract.html#.createContract">createContract</a></li><li data-type="method" id="contract-getInstance-nav"><a href="module-contract.html#.getInstance">getInstance</a></li><li data-type="method" id="contract-init-nav"><a href="module-contract.html#.init">init</a></li></ul></li><li id="utils-nav"><a href="module-utils.html">utils</a><ul class='methods'><li data-type="method" id="utils-getConfig-nav"><a href="module-utils.html#.getConfig">getConfig</a></li><li data-type="method" id="utils-parseLogLevels-nav"><a href="module-utils.html#.parseLogLevels">parseLogLevels</a></li><li data-type="method" id="utils-textsEqual-nav"><a href="module-utils.html#.textsEqual">textsEqual</a></li></ul></li><li id="wallet-nav"><a href="module-wallet.html">wallet</a><ul class='methods'><li data-type="method" id="wallet-createEncryptedAccount-nav"><a href="module-wallet.html#.createEncryptedAccount">createEncryptedAccount</a></li><li data-type="method" id="wallet-createSignerEth-nav"><a href="module-wallet.html#.createSignerEth">createSignerEth</a></li><li data-type="method" id="wallet-init-nav"><a href="module-wallet.html#.init">init</a></li><li data-type="method" id="wallet-loadEncryptedAccount-nav"><a href="module-wallet.html#.loadEncryptedAccount">loadEncryptedAccount</a></li><li data-type="method" id="wallet-pay-nav"><a href="module-wallet.html#.pay">pay</a></li><li data-type="method" id="wallet-payTest-nav"><a href="module-wallet.html#.payTest">payTest</a></li><li data-type="method" id="wallet-prepareSignerEth-nav"><a href="module-wallet.html#.prepareSignerEth">prepareSignerEth</a></li><li data-type="method" id="wallet-saveEncryptedAccount-nav"><a href="module-wallet.html#.saveEncryptedAccount">saveEncryptedAccount</a></li><li data-type="method" id="wallet-unlockEncryptedAccount-nav"><a href="module-wallet.html#.unlockEncryptedAccount">unlockEncryptedAccount</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#getFileKeySpace">getFileKeySpace</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#utils">utils</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        compile/src/compile.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>'use strict'
// Compile with solcjs
const fs         = require('fs')
const path       = require('path')
const solc       = require('solc')
const assert     = require('chai').assert
const { keccak } = require('ethereumjs-util')
const { List, Map, Set }
                 = require('immutable')
const { ContractsManager, awaitOutputter, getInputsToBuild }
                 = require('demo-contract')

const { traverseDirs, ensureDir, COMPILES_DIR, DEMO_SRC_PATH, fromJS, toJS,
        getImmutableKey, setImmutableKey, textsEqual, immEqual, Logger }
                 = require('demo-utils')

const LOGGER = new Logger('Compiler')

const compiles = {}

const ZEPPELIN_SRC_PATH_WS  = '../../node_modules/openzeppelin-solidity/contracts'
const ZEPPELIN_SRC_PATH_PKG = './node_modules/openzeppelin-solidity/contracts'

compiles.ZEPPELIN_SRC_PATH = fs.existsSync(ZEPPELIN_SRC_PATH_WS) ?
  ZEPPELIN_SRC_PATH_WS : ZEPPELIN_SRC_PATH_PKG

const { Flattener } = require('./flattener')

/**
 * A reusable Compiler for Democracy.js with a search path and custom outputter.
 * @class Compiler
 * @memberof module:compile
 * @param sourcePathList {Array} of strings for local directories. Can omit the `./` for relative paths.
 * @param bm {Object} optional, a BuildsManager if you've already created one with the
 *        inputters and outputters you need, possibly shared with a Linker and Deployer.
 * @param flatten {Boolean} whether to save a flattened source file into `/sourcesFlattened/${sourceFileName}`
 * @param outputFull {Boolean} where to save fill compile outputs into `/compileOutputs/$(sourceFileName}`
 */
compiles.Compiler = class {
  
  constructor({sourcePathList, bm, flatten, outputFull}) {
    // Add default paths and remove empty directories
    this.sourcePathSet = new Set(sourcePathList)
      .add(DEMO_SRC_PATH).add(compiles.ZEPPELIN_SRC_PATH).filter((d) => d)
    this.sourcePathSet.map((d) => { ensureDir(d) })
    this.cm = bm || new ContractsManager(...arguments)
    this.flatten = flatten || false
    this.outputFull = outputFull || false
  }

  /**
   * Return the internal contracts manager, for cleaning and getting contracts
   * with the same start source path, inputter, and outputter.
   */
  getContractsManager() {
    return this.cm
  }

  /**
   * Format the output from `solc` compiler into an Immutable {Map}
   * Stage 5 from
   * https://github.com/invisible-college/democracy/master/packages/compile/README.md
   * @param solcOutputContract an Immutable {Map} of contracts output from solc
   * @param requestedInputs an Immutable {Map} of contract names to source content
   * @param existingOutputs an Immutable {Map} of contract names to compiled output
   * @return an Immutable {Map} of contract names to compiled output
   */
  getCompileOutputFromSolc(solcOutputContracts, requestedInputs, existingOutputs) {
    // Filter compiled outputs to those in the requested set, and add contractName
    const requestedOutputs = solcOutputContracts.flatMap((j) => j).filter(
      (contract, contractName) => {
        return requestedInputs.has(contractName)
      })
    const tuples = requestedOutputs.map(async (contract, contractName) => {
           
      const now = new Date() 
      const inputHash = requestedInputs.get(contractName).get('inputHash') 
      const bytecode = contract.get('evm').get('bytecode').get('object') 
      assert(bytecode)
      const preHash = Map({
        type       : 'compile',
        name       : contractName,
        code       : bytecode,
        abi        : contract.get('abi'),
        inputHash  : inputHash,
        timestamp  : now.getTime(),
        dateTime   : now.toUTCString(),
      })
      const output = preHash.set('contentHash', keccak(JSON.stringify(preHash)).toString('hex'))
      // In some other place, the abiString is useful as a web output
      //const abiString = `abi${contract.name} = ${JSON.stringify(output['abi'], null, 2)}`
      if (existingOutputs.has(contractName) &amp;&amp;
          existingOutputs.get(contractName).get('inputHash') === inputHash) {
        LOGGER.debug(`${contract.name} is up-to-date with hash ${inputHash}, not overwriting.`)
        return [contractName, existingOutputs.get(contractName)]
      } else {
        return [contractName, await this.cm.setContract(contractName, output)]
      }
    })
    
    return Promise.all(List(tuples.values()).toJS()).then((pairs) => { return Map(pairs) })
  }
  
  /**
   * Reformat a sourceMap for solc where keys are Solidity filenames
   * and values are the Solidity source files themselves.
   * @param inputsToBuild an Immutable {Map} with members `filename` for the
   *        original Solidity filename and `source` is the original Solidity source text.
   *        the key does not matter.
   * @return a {Object} suitable for solc mapping filenames to a nested object of
   *         `content` to source file.
   */
  getSourceMapForSolc(inputsToBuild) {
    return new Map(List(inputsToBuild.values()).map((val) => {
      const fn = val.get('filename')
      assert(val.get('source'), `${fn} contains null source`)
      return [ val.get('filename'), { content: val.get('source') } ]
    })) 
  } 
 
 /**
  * Traverse solidity source files from disk and build requested inputs, and a
  * solidity findImports callback function.
  * @param { source } the filename of the requested source file input to compile, could be empty for compile all files found
  * @param { flattener } object to collect sources for flattening
  * @return { findImports } a callback for solc to resolve import statements
  * @return { requestedInputs } an Immutable {Map} of filenames as keys and source file contents as values
  */ 
  getRequestedInputsFromDisk(source, flattener) {
    const allInputFiles = []
    const inputs = {}
    
    // Filter out empty paths
    const queue = this.sourcePathSet.toJS()

    traverseDirs(
      queue,
      (fnParts) => { return ((fnParts.length > 1) &amp;&amp; !fnParts[1].startsWith('sol')) },
      function(source, f) {
        allInputFiles.push(path.basename(f))
        let paths = f.split(path.sep)
        const keys = []
        // This is a hack to push all suffixes of a contract path
        // since it's not clear which one solcjs will request
        // in findImport below
        do {
          keys.push(paths.join(path.sep))
          if (paths.length &lt;= 1) { break }
          paths = paths.slice(-(paths.length - 1))
        } while(true)
        const sourceObj = {source: source, inputHash: keccak(source).toString('hex')}
        keys.forEach((key) => {
          if (inputs[key]) { LOGGER.warn(`Replacing import ${key} with ${f}`) }
          inputs[key] = sourceObj
        })
      }
    )
    
    if (!allInputFiles || allInputFiles.length == 0) {
      LOGGER.warn("No source files found.")
    }

    function findImports (path) {
      assert(inputs[path], `Import not found: ${path}`)
      LOGGER.debug(`import ${inputs[path].source}`)
      flattener.addSource(path, inputs[path].source)
      return { contents: inputs[path].source }
    }

    // Filter out . and ..
    const inputFiles = (source &amp;&amp; source.length > 2) ?
      List([path.basename(source)]) : List(allInputFiles)
    
    // Reformat keys to strip filename extensions, but keep the original filename as member
    const requestedInputs = new Map(inputFiles.map((name) => {
      const value = new Map(inputs[name]).set('filename', name) 
      assert(name.split('.')[1].startsWith('sol'))
      assert(inputs[name], `${name} not found in paths ${this.sourcePathSet.toJS()}`)
      flattener.addSource(name, inputs[name].source)
      return [ name.split('.')[0], value ]
    }))

    return {
      requestedInputs  : requestedInputs, 
      findImports      : findImports,
    }
  } 

  /**
   * Flatten sources and update it in the contracts manager outputter if the hash
   * is different (content has changed.)
   *
   * @method updateFlatten
   * @memberof module:compile
   * @param flattener a Flattener object that has been collecting sources during compilation.
   * @param sourceFile the top-level source filename with extension
   */
  async updateFlatten(flattener, sourceFile) {
    if (!this.flatten) { return }
    const oldOutput = await this.cm.inputter(`sourcesFlattened/${sourceFile}`, new Map({}))
    const oldHash = oldOutput.get('inputHash')
    const flattenedSource = flattener.flatten()
    const newHash = keccak(flattenedSource).toString('hex')
    if (oldHash !== newHash) {
      LOGGER.info(`Flattened source out-of-date, re-flattening.`)
      LOGGER.debug(`old hash ${oldHash} vs. new hash ${newHash}`)
      await this.cm.outputter(`sourcesFlattened/${sourceFile}`,
                              new Map({ 'flattenedSource' : flattenedSource,
                                        'inputHash'       : newHash }),
                                        true)
    } else {
      const diffLine = textsEqual(oldOutput.get('flattenedSource'), flattenedSource) 
      assert( diffLine === -1, `Flattened sources differ at line ${diffLine}` )
    }
  }

  async updateCompileOutput(compileOutput, sourceFile) {
    if (!this.outputFull) { return }
    const oldOutput = await this.cm.inputter(`compileOutputs/${sourceFile}`, new Map({}))
    const oldHash = oldOutput.get('inputHash')
    const newHash = keccak(JSON.stringify(compileOutput)).toString('hex')
    LOGGER.debug(`old hash ${oldHash} vs. new hash ${newHash}`)
    if (oldHash !== newHash) {
      LOGGER.info(`Compile output out-of-date, re-writing.`)
      await this.cm.outputter(`compileOutputs/${sourceFile}`,
                              new Map({ ...compileOutput,
                                        'inputHash' : newHash }),
                                        true)
    } else {
      // TODO Debug this later
      //const same = immEqual(oldOutput, fromJS( compileOutput )) 
      //assert(same, `Compile output does not match, but inputHash was same` )
    }
  }

  /**
   * Main compile method. Takes a Solidity source file name and produces compile artifacts
   * in the associated contracts manager (either remote or in a local store)
   *
   * @method compile
   * @memberof module:compile
   * @param source {string} name of source file to compile, including Solidity extension
   * @param contracts {Map} from a ContractsManager
   * @return compile output as an Immutable {Map}
   */
  async compile(source) {
    // Open contracts installed by npm -E zeppelin-solidity
    // Open contracts from democracy
   
    const flattener = new Flattener() 
    const { requestedInputs, findImports }
      = this.getRequestedInputsFromDisk(source, flattener)

    const { contractOutputs: existingOutputs } = await this.cm.getContracts()
    const inputsToBuild = getInputsToBuild(requestedInputs, existingOutputs)

    const sourcesToBuild = this.getSourceMapForSolc(inputsToBuild)

    if (sourcesToBuild.count() === 0) {
      // Hooray, nothing to build. Return existing outputs as if we had built it.
      return existingOutputs.filter((val, key) => { return requestedInputs.has(key) })
    }

    const inputs = {
      language: 'Solidity',
      settings: {
        outputSelection: {
          '*': {
            '*': [ '*' ]
          }
        }
      },
      sources: toJS( sourcesToBuild ),
    }

    const outputs = JSON.parse(solc.compile(JSON.stringify(inputs), findImports))
    if (outputs.errors) {
      LOGGER.error('ERRORS', JSON.stringify(outputs.errors))
      throw new Error(outputs.errors)
    }
    assert.ok(outputs.contracts, `Expected compile output for requested sources`)
    
    await this.updateFlatten(flattener, source)
    await this.updateCompileOutput(outputs, source)

    assert( Map.isMap(requestedInputs) )
    return this.getCompileOutputFromSolc(fromJS( outputs.contracts ),
                                         requestedInputs, existingOutputs)
  }

}

module.exports = compiles
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
